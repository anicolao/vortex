function j(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function I(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function k(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(i=>typeof i=="function")){const i=e.map(c=>typeof c=="function"?`function ${c.name||"unnamed"}()`:typeof c).join(", ");throw new TypeError(`${t}[${i}]`)}}var E=e=>Array.isArray(e)?e:[e];function z(e){const t=Array.isArray(e[0])?e[0]:e;return k(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function A(e,t){const i=[],{length:c}=e;for(let o=0;o<c;o++)i.push(e[o].apply(null,t));return i}var x=class{constructor(e){this.value=e}deref(){return this.value}},D=typeof WeakRef<"u"?WeakRef:x,O=0,w=1;function h(){return{s:O,v:void 0,o:null,p:null}}function T(e,t={}){let i=h();const{resultEqualityCheck:c}=t;let o,s=0;function r(){var m;let n=i;const{length:d}=arguments;for(let p=0,v=d;p<v;p++){const f=arguments[p];if(typeof f=="function"||typeof f=="object"&&f!==null){let l=n.o;l===null&&(n.o=l=new WeakMap);const y=l.get(f);y===void 0?(n=h(),l.set(f,n)):n=y}else{let l=n.p;l===null&&(n.p=l=new Map);const y=l.get(f);y===void 0?(n=h(),l.set(f,n)):n=y}}const u=n;let a;if(n.s===w)a=n.v;else if(a=e.apply(null,arguments),s++,c){const p=((m=o==null?void 0:o.deref)==null?void 0:m.call(o))??o;p!=null&&c(p,a)&&(a=p,s!==0&&s--),o=typeof a=="object"&&a!==null||typeof a=="function"?new D(a):a}return u.s=w,u.v=a,a}return r.clearCache=()=>{i=h(),r.resetResultsCount()},r.resultsCount=()=>s,r.resetResultsCount=()=>{s=0},r}function W(e,...t){const i=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,c=(...o)=>{let s=0,r=0,n,d={},u=o.pop();typeof u=="object"&&(d=u,u=o.pop()),j(u,`createSelector expects an output function after the inputs, but received: [${typeof u}]`);const a={...i,...d},{memoize:m,memoizeOptions:p=[],argsMemoize:v=T,argsMemoizeOptions:f=[]}=a,l=E(p),y=E(f),R=z(o),b=m(function(){return s++,u.apply(null,arguments)},...l),S=v(function(){r++;const N=A(R,arguments);return n=b.apply(null,N),n},...y);return Object.assign(S,{resultFunc:u,memoizedResultFunc:b,dependencies:R,dependencyRecomputations:()=>r,resetDependencyRecomputations:()=>{r=0},lastResult:()=>n,recomputations:()=>s,resetRecomputations:()=>{s=0},memoize:m,argsMemoize:v})};return Object.assign(c,{withTypes:()=>c}),c}var g=W(T),$=Object.assign((e,t=g)=>{I(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const i=Object.keys(e),c=i.map(s=>e[s]);return t(c,(...s)=>s.reduce((r,n,d)=>(r[i[d]]=n,r),{}))},{withTypes:()=>$});const F=e=>e.auth.user,C=e=>e.events.log,B=g([C],e=>{const t={};return e.forEach(i=>{const{type:c,payload:o}=i;if(c==="ADD_EXPENSE"){const{payerId:s,amount:r,splitWith:n}=o,d=r/n.length;t[s]=(t[s]||0)+r,n.forEach(u=>{t[u]=(t[u]||0)-d})}else if(c==="SETTLE_DEBT"){const{fromId:s,toId:r,amount:n}=o;t[s]=(t[s]||0)+n,t[r]=(t[r]||0)-n}}),t}),P=g([B,F],(e,t)=>t&&e[t.uid]||0),U=g([C],e=>[...e].reverse().slice(0,20));export{U as a,B as b,P as s};
